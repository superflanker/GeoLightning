"""
Mealpy ESO Wrapper
==================

Electrical Storm Optimization (ESO) Algorithm

Summary
-------
This module implements the Electrical Storm Optimization (ESO) algorithm, a nature-inspired 
metaheuristic that simulates the dynamic behavior of electrical storms to solve continuous 
optimization problems. It models the interactions between field intensity, resistance, 
conductivity, and ionization zones to guide the search process in the solution space.

Author
------
Augusto Mathias Adams <augusto.adams@ufpr.br>

Contents
--------
- ESO class: core optimizer implementing the electrical storm metaphor.
- Parameters include iteration-dependent field behavior and selective ionization.

Notes
-----
This module is part of the activities of the discipline 
EELT 7019 - Applied Artificial Intelligence, Federal University of ParanÃ¡ (UFPR), Brazil.

Dependencies
------------
- numpy
- mealpy
"""


from mealpy import Optimizer
from mealpy.utils.agent import Agent
import numpy as np


class ESO(Optimizer):
    """
    Electrical Storm Optimization (ESO)

    A bio-inspired metaheuristic algorithm that simulates the physical behavior of
    electrical storms, including concepts such as field strength, intensity,
    conductivity (ke), and ionized zones to guide the population towards the global optimum.

    Parameters
    ----------
    epoch : int, optional
        Maximum number of iterations (generations) of the algorithm. Default is 1000.
    pop_size : int, optional
        Number of candidate solutions (bolts) in the population. Default is 50.
    **kwargs : dict
        Additional arguments inherited from the `Optimizer` class, such as `problem`, `verbosity`, etc.

    Attributes
    ----------
    field_resistance : float
        Normalized measure of spatial variation of the population.
    field_intensity : float
        Field strength in the current iteration, influenced by ke and progress.
    storm_power : float
        Power of the field generated by the storm, used to propagate the solutions.
    ke : float
    Equivalent electrical conductivity, controlling disturbances.
    stagnation : np.ndarray
        Individual stagnation vector of each agent.
    ionized_areas_index : list of int
        Indices of the most promising solutions at the current time.
    ionized_areas_positions : list of np.ndarray
        Positions corresponding to the ionized zones.
    """

    def __init__(self, epoch=1000, pop_size=50, **kwargs):
        super().__init__(**kwargs)
        self.epoch = self.validator.check_int("epoch", epoch, [1, 100000])
        self.pop_size = self.validator.check_int(
            "pop_size", pop_size, [5, 10000])
        self.set_parameters(["epoch", "pop_size"])
        self.is_parallelizable = True
        self.sort_flag = False
        self.field_resistance = 0
        self.field_intensity = 0
        self.storm_power = 0
        self.ke = 0
        self.stagnation = np.zeros(self.pop_size, dtype=int)
        self.ionized_areas_index = []
        self.ionized_areas_positions = []

    def initialize_variables(self):
        pop = [np.random.uniform(self.problem.lb, self.problem.ub)
               for _ in range(self.pop_size)]
        self.pop = []
        for _, new_pos in enumerate(pop):
            target = self.problem.get_target(new_pos)
            new_agent = Agent(new_pos, target)
            self.pop.append(new_agent)
        self.stagnation = np.zeros(self.pop_size, dtype=int)
        self.ionized_areas_index = []
        self.ionized_areas_positions = []
        self.field_resistance = 0
        self.field_intensity = 0
        self.storm_power = 0
        self.ke = 0

    def exp(self, x):
        """
        Exp protected against overflow.

        Parameters
        ----------
        x : float
            Input value.

        Returns
        -------
        float
            Result of the exponential of x, with safety limits.
        """
        x = np.clip(x, -709, 709)  # evitar overflow
        return np.exp(x)

    def log(self, x):
        """
        Safe natural logarithm function.

        Clips the input to avoid numerical issues with very small or non-positive values,
        ensuring a stable logarithmic computation.

        Parameters
        ----------
        x : float or ndarray
            Input value or array of values to compute the natural logarithm.

        Returns
        -------
        float or ndarray
            The natural logarithm of the clipped input.
        """
        x = np.clip(x, np.finfo(np.float64).tiny, None)
        return np.log(x)

    def logistic_curve(self, value, multiplier):
        """
        Modified logistic activation curve.

        Computes a smooth nonlinear transformation based on the input value and a scaling multiplier.
        This function enhances sensitivity near critical transitions, combining a standard logistic
        curve with a logarithmic correction term.

        Parameters
        ----------
        value : float
            The input value to be transformed.
        multiplier : float
            The scaling factor that controls the steepness of the logistic response.

        Returns
        -------
        float
            Transformed output in the range (0, 1), emphasizing local adaptivity.
        """
        return 1 / (1 + self.exp(-multiplier * (value - np.abs(self.log(1 - value + 1e-50)))))

    def identify_ionized_areas(self):
        """
        Identify the most promising ionized zones in the population.

        Selects a subset of agents with the best fitness values, based on the current
        field resistance, to define the ionized areas. These zones guide the propagation
        of new candidate solutions in subsequent steps.

        Updates
        -------
        ionized_areas_index : list of int
            Indices of the selected ionized agents in the population.

        ionized_areas_positions : list of ndarray
            Positions corresponding to the ionized zones.
        """
        n_ion = int(self.pop_size * (self.field_resistance / 2))
        sorted_idx = np.argsort([agent.target.fitness for agent in self.pop])
        if self.problem.minmax == "min":
            self.ionized_areas_index = sorted_idx[:n_ion]
        else:
            self.ionized_areas_index = sorted_idx[-n_ion:]
        self.ionized_areas_positions = [
            self.pop[i].solution.copy() for i in self.ionized_areas_index]

    def calculate_field_resistance(self):
        """
        Calculate the normalized field resistance.

        Estimates the spatial resistance of the current population by computing the ratio
        between the standard deviation and the peak-to-peak range of fitness values. This
        metric reflects the population's dispersion and guides the storm's behavior.

        Updates
        -------
        field_resistance : float
            Normalized resistance of the field, bounded away from zero.
        """
        positions = np.array([agent.target.fitness for agent in self.pop])
        max_diff = np.ptp(positions)
        max_diff = max(max_diff, 1e-6)
        self.field_resistance = np.std(positions) / max_diff

    def calculate_ke(self):
        """
        Compute the equivalent electrical conductivity (ke).

        Calculates the adaptive conductivity coefficient based on the current field resistance.
        This value modulates the magnitude of perturbations during the propagation phase, 
        balancing exploration and exploitation.

        Updates
        -------
        ke : float
            Equivalent electrical conductivity used to scale positional perturbations.
        """
        beta = self.logistic_curve(self.field_resistance, self.exp(
            self.field_resistance) / (self.field_resistance + 1e-50))
        self.ke = self.exp(self.field_resistance) + (self.exp(1 - self.field_resistance)
                                                     * np.abs(self.log(self.field_resistance + 1e-50))) * beta

    def adjust_field_intensity(self):
        """
        Adjust the electric field intensity.

        Dynamically updates the field intensity based on the current field resistance,
        iteration progress, and electrical conductivity. This value controls the scaling
        of the storm power during propagation.

        Updates
        -------
        field_intensity : float
            Current intensity of the field, increasing adaptively with iteration progress.
        """
        iter_factor = self.epoch_current / max(self.epoch, 1)
        gamma = 1 / (1 + self.exp(-(self.exp(self.field_resistance) / (self.field_resistance + 1e-50))
                     * (self.field_resistance - np.abs(self.log(1 - iter_factor)))))
        self.field_intensity = 1e-50 + self.ke * gamma

    def calculate_storm_power(self):
        """
        Calculate the storm power.

        Computes the overall storm power as a function of field resistance, field intensity,
        and electrical conductivity. This parameter determines the scale of movement for agents
        during the propagation step.

        Updates
        -------
        storm_power : float
            The resulting power of the storm, used to guide solution propagation.
        """
        self.storm_power = self.field_resistance * \
            (self.field_intensity ** self.ke)

    def propagate(self, idx):
        """
        Propagate a new candidate solution based on ionization and storm dynamics.

        Generates a new agent by either reinitialization (in case of stagnation),
        direct multiplication with storm power (if ionized), or perturbed averaging
        of ionized centers (if not). Ensures that all new positions remain within bounds.

        Parameters
        ----------
        idx : int
            Index of the agent to be propagated.

        Returns
        -------
        Agent
            A new agent instance with updated position and evaluated target.
        """
        agent = self.pop[idx]
        if self.stagnation[idx] > 2:
            self.stagnation[idx] = 0
            pos_new = np.random.uniform(self.problem.lb, self.problem.ub)
            pos_new = self.amend_solution(pos_new)
            target = self.problem.get_target(pos_new)
            new_agent = Agent(pos_new, target)
            return new_agent

        if idx in self.ionized_areas_index:
            pos_new = agent.solution * self.storm_power
        else:
            if not self.ionized_areas_positions:
                pos_new = np.random.uniform(self.problem.lb, self.problem.ub)
            else:
                accum = np.zeros_like(agent.solution)
                valid = 0
                for center in self.ionized_areas_positions:
                    pert = np.random.uniform(-self.ke,
                                             self.ke, size=self.problem.n_dims)
                    update = center + \
                        (pert * self.storm_power * self.exp(self.ke))
                    if np.all(np.isfinite(update)):
                        accum += update
                        valid += 1
                if valid > 0:
                    pos_new = accum / valid
                else:
                    pos_new = np.random.uniform(
                        self.problem.lb, self.problem.ub)

        pos_new = self.amend_solution(pos_new)
        pos_new = np.clip(pos_new, self.problem.lb, self.problem.ub)
        target = self.problem.get_target(pos_new)
        new_agent = Agent(pos_new, target)
        return new_agent

    def evolve(self, epoch):
        """
        Perform one iteration of the ESO optimization process.

        Updates the internal storm dynamics (ionized zones, resistance, conductivity,
        intensity, and power), then applies the propagation rule to each agent.
        Accepts new agents based on fitness improvement and tracks stagnation.

        Parameters
        ----------
        epoch : int
            Current iteration number within the optimization process.
        """
        if len(self.stagnation) != len(self.pop):
            self.stagnation = np.zeros(len(self.pop), dtype=int)
            self.field_resistance = 0
            self.field_intensity = 0
            self.storm_power = 0
            self.ke = 0
            self.ionized_areas_index = []
            self.ionized_areas_positions = []
        self.epoch_current = epoch
        self.identify_ionized_areas()
        self.calculate_field_resistance()
        self.calculate_ke()
        self.adjust_field_intensity()
        self.calculate_storm_power()

        for idx, agent in enumerate(self.pop):
            new_agent = self.propagate(idx)
            if self.compare_target(new_agent.target, agent.target):
                self.pop[idx] = new_agent
                self.stagnation[idx] = 0
            else:
                self.stagnation[idx] += 1
